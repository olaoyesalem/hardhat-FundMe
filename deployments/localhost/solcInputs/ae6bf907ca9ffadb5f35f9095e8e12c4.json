{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/FundMe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// 1. Pragma\npragma solidity ^0.8.0;\n// 2. Imports\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\nimport \"./PriceConverter.sol\";\nerror notOwner();\nerror sendFailed();\n\n// if a variable is set one time to a particular value,  we use the keyword \"constant\", \" Immutable\";\n// the variables constants no longer take up a storage spot rather they are inducted into the byte code of the smart contract\n\ncontract FundMe{\n    using PriceConverter for uint256;\n\nuint256 public constant MINIMUM_USD = 50*1e18; \nAggregatorV3Interface public priceFeed;\n\n\nconstructor(address priceFeedAddress){  // constructor is a function that gets automatically called up once the contract is deployed.\n  i_owner=msg.sender;   \n  priceFeed = AggregatorV3Interface(priceFeedAddress);\n}\n\naddress[] public funders; // to keep list of funders\n\nmapping(address=>uint256) public addressToAmountFunded; // to map funders to the amount deposited\n\n\naddress public immutable i_owner;\n\n\n\nfunction fund() public payable onlyOwner {\n\nrequire(msg.value.getConversionRate( priceFeed)>=MINIMUM_USD,\"Didn't send enough\"); \n funders.push(msg.sender);\n\n addressToAmountFunded [msg.sender]+=msg.value;// mapping the addrsses to the  amount they funded\n}\n\nfunction Withdraw() public onlyOwner {\n\n    for(uint256 fundersIndex=0; fundersIndex<funders.length; fundersIndex++){\naddress funder = funders[fundersIndex];\naddressToAmountFunded[funder]=0; \n }\n\nfunders = new address[](0);\n//payable(msg.sender).transfer(address(this).balance);\n\n// send\n// bool sendSuccess = payable(msg.sender).send(address(this).balance);\n// if(!sendSuccess){\n//     revert sendFailed();\n// }\n// call\n// this is a lower level command; it can be used to call functions wvwn without having thier ABI\n\n(bool callSuccess, )=payable(msg.sender).call{value: address(this).balance}(\"\");\nrequire(callSuccess,\"call Failed\");\n\n\n//   modifier onlyOwner{ \n\n// if(msg.sender !=i_owner){\n//     revert notOwner();\n// }\n// _;\n// }\n// To still gets the details of the transaaction if  someone calls the contract without using the fund();\n// recieve()\n \n}\nmodifier onlyOwner{\n         if(msg.sender !=i_owner){\n    revert notOwner();\n}\n    _;\n}\nreceive() external payable{\n    fund();\n}\n\n// fallback\nfallback() external payable{\n    fund();\n} \n\n}\n\n\n\n\n\n\n\n"
    },
    "contracts/PriceConverter.sol": {
      "content": "//SPDX-License-Identifier:MIT\npragma solidity ^0.8.0;\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\nlibrary PriceConverter{\nfunction getPrice(AggregatorV3Interface priceFeed)internal view returns(uint256){\n  \n    //AggregatorV3Interface priceFeed = AggregatorV3Interface(0x8A753747A1Fa494EC906cE90E9f37563A8AF630e);\n    (,int256 price,,,)=priceFeed.latestRoundData();\n     //This is the price of ETH in USD \n    // $1,280.00000000 = 1eth // this has 8 decimal place\n    return uint256(price*1e10);\n}\nfunction getVersion(AggregatorV3Interface priceFeed) internal view returns(uint256){\n    //AggregatorV3Interface priceFeed = AggregatorV3Interface(0x8A753747A1Fa494EC906cE90E9f37563A8AF630e);\n    return priceFeed.version();\n}\nfunction getConversionRate(uint256 ethAmount,AggregatorV3Interface priceFeed)internal view returns(uint256){// to get the amount of any ETH in USD\nuint256 ethPrice= getPrice( priceFeed);\n//3000_000000000000000000 = ETH/USD price\n// 1_000000000000000000 (wei) ETH we are sending\n uint256 ethPriceInUsd = (ethPrice * ethAmount)/1e18;\n //3000 USD\nreturn ethPriceInUsd;\n}\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}